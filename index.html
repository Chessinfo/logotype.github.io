Фон
Flexbox Layout (Гибкая коробка) модуль (Рекомендация кандидата W3C по состоянию на октябрь 2017 года) нацелен на обеспечение более эффективного способа размещения, выравнивания и распределения пространства между элементами в контейнере, даже когда их размер неизвестен и / или является динамическим (таким образом, слово «гибкий»).

Основная идея гибкого макета состоит в том, чтобы дать контейнеру возможность изменять ширину / высоту его элементов (и порядок), чтобы наилучшим образом заполнить доступное пространство (в основном, для размещения на всех типах устройств отображения и размеров экрана). Гибкий контейнер расширяет элементы, чтобы заполнить доступное свободное пространство, или сжимает их, чтобы предотвратить переполнение.

Наиболее важно то, что макет flexbox не зависит от направления, в отличие от обычных макетов (блок на вертикальной основе и встроенный на горизонтальной основе). Хотя они хорошо работают для страниц, им не хватает гибкости (без каламбура) для поддержки больших или сложных приложений (особенно когда речь идет об изменении ориентации, изменении размера, растяжении, сжатии и т. Д.).

Замечания: Макет Flexbox наиболее подходит для компонентов приложения и небольших макетов, в то время как сетка макет предназначен для крупномасштабных макетов.

Основы и терминология
Поскольку flexbox — это целый модуль, а не одно свойство, он включает в себя множество вещей, включая весь набор свойств. Некоторые из них предназначены для установки на контейнере (родительский элемент, известный как «гибкий контейнер»), тогда как другие предназначены для установки на дочерние элементы (так называемые «гибкие элементы»).

Если «обычная» компоновка основана на блочном и линейном направлениях потока, гибкая компоновка основана на «направлениях гибкого потока». Пожалуйста, посмотрите на этот рисунок из спецификации, объясняя основную идею гибкого макета.

Диаграмма, объясняющая терминологию flexbox. Размер по главной оси flexbox называется основным размером, другое направление - поперечный размер. Эти размеры имеют главное начало, основной конец, поперечный старт и поперечный конец.
Элементы будут размещены в соответствии с main axis (от main-start в main-end) или поперечная ось (от cross-start в cross-end).

главная ось — Основная ось гибкого контейнера — это основная ось, вдоль которой выкладываются гибкие элементы. Осторожно, оно не обязательно горизонтальное; это зависит от flex-direction собственность (см. ниже).
главный старт | Основной конец — Гибкие элементы помещаются в контейнер, начиная с основного и заканчивая основным.
основной размер — Ширина или высота гибкого элемента, в зависимости от того, что находится в основном измерении, является основным размером элемента. Свойство основного размера элемента flex — это свойство «ширина» или «высота», в зависимости от того, что находится в основном измерении.
поперечная ось — Ось, перпендикулярная главной оси, называется поперечной осью. Его направление зависит от направления главной оси.
кросс-старт | кросс-конец — Гибкие линии заполнены предметами и помещены в контейнер, начиная со стороны поперечного начала гибкого контейнера и по направлению к поперечной стороне.
размер креста — Ширина или высота гибкого элемента, который находится в поперечном измерении, является поперечным размером элемента. Свойство размера креста имеет значение «ширина» или «высота», которое находится в поперечном измерении.
Полное руководство по Flexbox 6
Свойства для родителей
(гибкий контейнер)
дисплей
Это определяет гибкий контейнер; встроенный или блок в зависимости от заданного значения. Это позволяет гибкий контекст для всех его прямых потомков.

.container {
  display: flex; /* or inline-flex */
}
Обратите внимание, что столбцы CSS не влияют на гибкий контейнер.

Flex-направление
показаны четыре возможных значения направления гибкого направления: сверху вниз, снизу вверх, справа налево и слева направо
Это устанавливает основную ось, таким образом определяя направление гибких элементов, помещаемых в гибкий контейнер. Flexbox — это (помимо дополнительной упаковки) концепция макета в одном направлении. Думайте о гибких предметах, как о первичных раскладках в горизонтальных рядах или вертикальных столбцах.

.container {
  flex-direction: row | row-reverse | column | column-reverse;
}
row (по умолчанию): слева направо в ltr; справа налево в rtl
row-reverse: справа налево в ltr; слева направо в rtl
column: такой же как row но сверху вниз
column-reverse: такой же как row-reverse но снизу вверх
Flex-обертка
два ряда коробок, первый наматывается на второй
По умолчанию все элементы Flex будут помещаться на одной строке. Вы можете изменить это и позволить обернуть элементы по мере необходимости этим свойством.

.container {
  flex-wrap: nowrap | wrap | wrap-reverse;
}
nowrap (по умолчанию): все гибкие элементы будут в одной строке
wrap: flex-элементы будут перенесены на несколько строк сверху вниз.
wrap-reverse: flex-элементы будут перенесены на несколько строк снизу вверх.
Есть некоторые визуальные демонстрации flex-wrap Вот,

Flex-поток
Это сокращение для flex-direction а также flex-wrap свойства, которые вместе определяют основную и поперечную оси гибкого контейнера. Значением по умолчанию является row nowrap,

.container {
  flex-flow: column wrap;
}
обосновывать-контент
гибкие элементы в гибком контейнере, демонстрирующие различные варианты интервалов
Это определяет выравнивание вдоль главной оси. Это помогает распределить дополнительный остаток свободного пространства, когда либо все гибкие элементы в строке негибкие, либо гибкие, но достигли своего максимального размера. Это также обеспечивает некоторый контроль над выравниванием элементов, когда они переполняют линию.

.container {
  justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly | start | end | left | right ... + safe | unsafe;
}
flex-start (по умолчанию): элементы упакованы в направлении начала гибкого направления.
flex-end: элементы упакованы ближе к концу гибкого направления.
start: предметы упакованы к началу writing-mode направление.
end: предметы упакованы в конце writing-mode направление.
left: элементы упакованы по левому краю контейнера, если это не имеет смысла с flex-directionто это ведет себя как start,
right: предметы упакованы к правому краю контейнера, если это не имеет смысла с flex-directionто это ведет себя как start,
center: пункты центрированы вдоль линии
space-between: предметы равномерно распределены по линии; первый элемент находится в начале строки, последний элемент в конце строки
space-around: предметы равномерно распределены по линии с одинаковым пространством вокруг них. Обратите внимание, что визуально пробелы не равны, поскольку все элементы имеют одинаковое пространство с обеих сторон. Первый элемент будет иметь одну единицу пространства напротив края контейнера, но две единицы пространства между следующим элементом, потому что у следующего элемента есть свой собственный интервал, который применяется.
space-evenly: элементы распределяются так, чтобы расстояние между любыми двумя элементами (и расстояние до краев) было одинаковым.
Обратите внимание, что поддержка браузером этих значений нюансов. Например, space-between никогда не получал поддержки от некоторых версий Edge, а start / end / left / right еще нет в Chrome. MDN имеет подробные графики, Самые безопасные значения flex-start, flex-end, а также center,

Есть также два дополнительных ключевых слова, которые вы можете связать с этими значениями: safe а также unsafe, С помощью safe гарантирует, что как бы вы ни занимались этим типом позиционирования, вы не можете выдвинуть элемент таким образом, чтобы он отображался за пределами экрана (например, сверху), чтобы контент тоже не мог прокручиваться (это называется «потеря данных»).

ALIGN-элементы
демонстрация различных вариантов выравнивания, например, все блоки, прикрепленные к верхней части гибкого родителя, к нижней части, вытянутые или вдоль базовой линии
Это определяет поведение по умолчанию для того, как гибкие элементы располагаются вдоль поперечная ось на текущей строке. Думайте об этом как justify-content версия для поперечной оси (перпендикулярно главной оси).

.container {
  align-items: stretch | flex-start | flex-end | center | baseline | first baseline | last baseline | start | end | self-start | self-end + ... safe | unsafe;
}
stretch (по умолчанию): растянуть, чтобы заполнить контейнер (все еще соблюдайте min-width / max-width)
flex-start / start / self-start: элементы размещаются в начале поперечной оси. Разница между ними невелика и заключается в уважении flex-direction правила или writing-mode правила.
flex-end / end / self-end: элементы размещаются в конце поперечной оси. Разница опять-таки тонкая и заключается в уважении flex-direction правила против writing-mode правила.
center: элементы расположены по центру поперечной оси
baseline: элементы выровнены, такие как их базовые линии
safe а также unsafe ключевые слова-модификаторы могут использоваться вместе со всеми остальными этими ключевыми словами (хотя примечание поддержка браузера) и помочь вам предотвратить выравнивание элементов таким образом, чтобы содержимое стало недоступным.

ALIGN-контент
примеры свойства align-content, в котором группа элементов кластеризована сверху или снизу или вытянута, чтобы заполнить пространство, или имеет интервал.
Это выравнивает линии гибкого контейнера в пределах, когда есть дополнительное пространство на поперечной оси, подобно тому, как justify-content выравнивает отдельные элементы в пределах главной оси.

Замечания: это свойство не действует, когда есть только одна строка изгибаемых элементов.

.container {
  align-content: flex-start | flex-end | center | space-between | space-around | space-evenly | stretch | start | end | baseline | first baseline | last baseline + ... safe | unsafe;
}
flex-start / start: предметы, упакованные до начала контейнера. (Больше поддерживается) flex-start чтит flex-direction пока start чтит writing-mode направление.
flex-end / end: предметы, упакованные до конца контейнера. (Больше поддержки) flex-end чтит flex-direction в то время как конец чтит writing-mode направление.
center: предметы по центру в контейнере
space-between: предметы равномерно распределены; первая строка находится в начале контейнера, а последняя — в конце
space-around: предметы равномерно распределены с равным пространством вокруг каждой строки
space-evenly: предметы равномерно распределены вокруг
stretch (по умолчанию): линии растягиваются, чтобы занять оставшееся пространство
safe а также unsafe ключевые слова-модификаторы могут использоваться вместе со всеми остальными этими ключевыми словами (хотя примечание поддержка браузера) и помочь вам предотвратить выравнивание элементов таким образом, чтобы содержимое стало недоступным.

Полное руководство по Flexbox 8
Недвижимость для детей
(гибкие элементы)
приказ
Диаграмма, показывающая порядок flexbox. Контейнер с элементами 1 1 1 2 3, -1 1 2 5 и 2 2 99.
По умолчанию гибкие элементы располагаются в исходном порядке. Однако order Свойство управляет порядком их появления в контейнере flex.

.item {
  order: 5; /* default is 0 */
}
прогибается вырастали
две строки элементов, первая имеет все элементы одинакового размера с одинаковыми числами сгибания-растяжения, вторая с центральным элементом в два раза большей ширины, поскольку его значение равно 2 вместо 1.
Это определяет способность гибкого элемента расти в случае необходимости. Он принимает значение без единицы, которое служит пропорцией. Он определяет, какое количество доступного пространства внутри гибкого контейнера должно занимать элемент.

Если все предметы имеют flex-grow При значении 1 оставшееся пространство в контейнере будет распределено одинаково для всех дочерних элементов. Если один из дочерних элементов имеет значение 2, оставшееся пространство займет в два раза больше места, чем остальные (или попытается, по крайней мере).


.item {
  flex-grow: 4; /* default 0 */
}
Отрицательные числа недействительны.

Flex-термоусадочная
Это определяет способность гибкого элемента сжиматься при необходимости.

.item {
  flex-shrink: 3; /* default 1 */
}
Отрицательные числа недействительны.

Flex-основа
Это определяет размер элемента по умолчанию перед распределением оставшегося пространства. Это может быть длина (например, 20%, 5rem и т. Д.) Или ключевое слово. auto Ключевое слово означает «посмотрите на мою ширину или высоту» (что было временно сделано main-size ключевое слово пока не устарело). content Ключевое слово означает «изменить его размер в зависимости от содержания элемента» — это ключевое слово пока не поддерживается, поэтому его сложно протестировать и узнать, какие у него братья. max-content, min-content, а также fit-content делать.

.item {
  flex-basis:  | auto; /* default auto */
}
Если установлено 0, дополнительное пространство вокруг содержимого не учитывается. Если установлено auto, дополнительное пространство распределяется на основе его flex-grow ценность. Смотрите этот рисунок.

сгибать
Это сокращение для flex-grow, flex-shrink а также flex-basis вместе взятые. Второй и третий параметры (flex-shrink а также flex-basis) не являются обязательными. По умолчанию 0 1 auto, но если вы установите его с одним числовым значением, это похоже на 1 0,

.item {
  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]
}
Рекомендуется использовать это сокращенное свойство а не устанавливать отдельные свойства. Сокращение устанавливает другие значения разумно.

Align-я
Один элемент со значением align-self размещается вдоль нижней части гибкого родителя, а не сверху, где находятся все остальные элементы.
Это позволяет выравнивание по умолчанию (или указанное align-items) быть переопределенным для отдельных элементов flex.

Пожалуйста, посмотрите align-items объяснение, чтобы понять доступные значения.

.item {
  align-self: auto | flex-start | flex-end | center | baseline | stretch;
}
Обратите внимание, что float, clear а также vertical-align не влияет на гибкий элемент.

Примеры
Давайте начнем с очень простого примера, решающего почти ежедневную проблему: идеальное центрирование. Это не может быть проще, если вы используете flexbox.

.parent {
  display: flex;
  height: 300px; /* Or whatever */
}

.child {
  width: 100px;  /* Or whatever */
  height: 100px; /* Or whatever */
  margin: auto;  /* Magic! */
}
Это зависит от того факта, что для auto в гибком контейнере поглощают дополнительное пространство. Так что установка вертикального поля auto сделает изделие идеально центрированным по обеим осям.

Теперь давайте использовать еще несколько свойств. Рассмотрим список из 6 предметов, все с фиксированными размерами, но могут быть авторазмера. Мы хотим, чтобы они были равномерно распределены по горизонтальной оси, чтобы при изменении размера браузера все масштабировалось хорошо и без медиазапросов.

.flex-container {
  /* We first create a flex layout context */
  display: flex;

  /* Then we define the flow direction 
     and if we allow the items to wrap 
   * Remember this is the same as:
   * flex-direction: row;
   * flex-wrap: wrap;
   */
  flex-flow: row wrap;

  /* Then we define how is distributed the remaining space */
  justify-content: space-around;
}
Выполнено. Все остальное — это просто стайлинг. Ниже ручка с этим примером. Обязательно зайдите в CodePen и попробуйте изменить размеры своих окон, чтобы увидеть, что происходит.



Давайте попробуем что-нибудь еще. Представьте, что у нас есть выровненный по правому краю элемент навигации в самом верху нашего веб-сайта, но мы хотим, чтобы он был сосредоточен на экранах среднего размера и на одной колонке на небольших устройствах. Достаточно просто.

/* Large */
.navigation {
  display: flex;
  flex-flow: row wrap;
  /* This aligns items to the end line on main-axis */
  justify-content: flex-end;
}

/* Medium screens */
@media all and (max-width: 800px) {
  .navigation {
    /* When on medium sized screens, we center it by evenly distributing empty space around items */
    justify-content: space-around;
  }
}

/* Small screens */
@media all and (max-width: 500px) {
  .navigation {
    /* On small screens, we are no longer using row direction but column */
    flex-direction: column;
  }
}


Давайте попробуем что-то еще лучше, играя с гибкостью гибких предметов! Как насчет первого в мобильном формате 3-колоночного макета с полным и верхним колонтитулом. И не зависит от исходного порядка.

.wrapper {
  display: flex;
  flex-flow: row wrap;
}

/* We tell all items to be 100% width, via flex-basis */
.wrapper > * {
  flex: 1 100%;
}

/* We rely on source order for mobile-first approach
 * in this case:
 * 1. header
 * 2. article
 * 3. aside 1
 * 4. aside 2
 * 5. footer
 */

/* Medium screens */
@media all and (min-width: 600px) {
  /* We tell both sidebars to share a row */
  .aside { flex: 1 auto; }
}

/* Large screens */
@media all and (min-width: 800px) {
  /* We invert order of first sidebar and main
   * And tell the main element to take twice as much width as the other two sidebars 
   */
  .main { flex: 2 0px; }
  .aside-1 { order: 1; }
  .main    { order: 2; }
  .aside-2 { order: 3; }
  .footer  { order: 4; }
}


Префикс Flexbox
Flexbox требует префикса некоторых поставщиков для поддержки большинства браузеров. Он не включает в себя предварительно добавленные свойства с префиксом поставщика, но на самом деле существуют совершенно разные имена свойств и значений. Это потому, что спецификация Flexbox со временем изменилась, создавая «Старый», «твинер» и «новый» версии.

Возможно, лучший способ справиться с этим — написать в новом (и окончательном) синтаксисе и запустить свой CSS через Autoprefixer, который очень хорошо справляется с запасными вариантами.

Или вот Sass @mixin чтобы помочь с некоторыми префиксами, которые также дают вам представление о том, что нужно сделать:

@mixin flexbox() {
  display: -webkit-box;
  display: -moz-box;
  display: -ms-flexbox;
  display: -webkit-flex;
  display: flex;
}

@mixin flex($values) {
  -webkit-box-flex: $values;
  -moz-box-flex:  $values;
  -webkit-flex:  $values;
  -ms-flex:  $values;
  flex:  $values;
}

@mixin order($val) {
  -webkit-box-ordinal-group: $val;  
  -moz-box-ordinal-group: $val;     
  -ms-flex-order: $val;     
  -webkit-order: $val;  
  order: $val;
}

.wrapper {
  @include flexbox();
}

.item {
  @include flex(1 200px);
  @include order(2);
}
Связанные свойства
Другие источники
ошибки
Flexbox, конечно, не без ошибок. Лучшая коллекция из тех, что я видел, — это Филип Уолтон и Грег Уитворт. Flexbugs, Это место с открытым исходным кодом для отслеживания всех из них, поэтому я думаю, что лучше всего просто сослаться на это.

Поддержка браузера
Разбит по «версии» flexbox:

(новый) означает недавний синтаксис из спецификации (например, display: flex;)
(tweener) означает странный неофициальный синтаксис с 2011 года (например, display: flexbox;)
(старый) означает старый синтаксис с 2009 года (например, display: box;)
Хром	Сафари	Fire Fox	опера	IE	край	Android	IOS
20- (старый)
21+ (новый)	3.1+ (старый)
6.1+ (новый)	2-21 (старый)
22+ (новый)	12.1+ (новый)	10 (твинер)
11+ (новый)	17+ (новый)	2.1+ (старый)
4.4+ (новый)	3.2+ (старый)
7.1+ (новый)
Браузер Blackberry 10+ поддерживает новый синтаксис.
